
	     C++
-------
Day 1
-------
Introduction
Agenda
Setup

Setup
-------
onlinegdb.com
Virtual box with ubuntu
Any other

Recap of C
------------

Assignments
------------
* Study types of constants
* Study types of variables wrt size, sign/unsign, range ...
* Study types of variables wrt scope and lifetime
* Study how integer values are stored in memory
* Study how floating values are stored in memory
* Study number systems
* Study operators, constructs

-----------------------------------------------
Program => code + data

code => function bodies
data => variables + constants
-----------------------------------------------
char ch1;
ch1=10;
-----------------------------------------------
char
unsigned char   0   to 255
signed char    -128 to 127
-----------------------------------------------
Constants and thier types
--------------------------
1234
67.89
67.89f
67.89F
1234U
1234UL
67.89L
67.89u
1234f
1234.0f
1234.f
-----------------------------------------------
How to understand
variables => read the declaration
functions => by drawing stack frames
-----------------------------------------------
int x;

storage=> code/text, data, stack, heap
          bss
-----------------------------------------------

===============================================
1234
12.34
printf("sizeof 12.34 is %lu\n", sizeof(12.34));
12.34f
12.34F
printf("sizeof 12.34f is %lu\n", sizeof(12.34f));
printf("sizeof 12.34F is %lu\n", sizeof(12.34F));
1234u
1234U
1234UL
printf("sizeof 1234 is %lu\n", sizeof(1234));
printf("sizeof 1234UL is %lu\n", sizeof(12.34UL));
12.34l
12.34u
1234f
1234.0f
1234.f
----------------
char ch1;
ch1=10;
ch1='a';
ch1=97;
----------------
unsigned char ch2;
ch2=256;
1 0000 0000
--------------------
'a'
--------------------
"mnopqr"
printf("size of \"mnopqr\" is\n", sizeof("mnopqr"));
'm'+'n'+'o'+'p'+'q'+'r'+0
'm'+'n'+'o'+'p'+'q'+'r'+'\0'
'm'+'n'+'o'+'p'+'q'+'r'+'0'   =====X

%d   '\0'
if else

--------------------
%d %s
--------------------
Print values of x, y, z
enum {x, y, z};
printf("%d %d %d\n", x, y, z);

enum {x=10, y, z};
enum {x, y=10, z};
enum {x, y=-10, z};
enum {x=12.34, y, z};

enum {x, y, z};
x=10;

int m=10;
enum {x=m, y, z};

#define m 10
enum {x=m, y, z};

enum {economic, sports, luxury};
------------------------------------

program => code + data

data => constants + variables
code => function bodies
------------------------------------
local, global, static
------------------------------------
int a;
a=10;
------------------------------------
int a=10;
-----------------------------------
Operators
---------
unary, binary, ternery

-5
10+20

--------------------------------------
Constructs
-----------
if, elseif, else.....

//float i=1;
int i=1;
int j=1;

switch(i)
{
	i=i+1;
	case 0:
	
	case j*1:

}
------------------------------
float f1=1.0;
f1=f1<<1;
printf("%f\n", f1);
------------------------------
==================================================

-----------------------------------------------

-------------------------------------------------------------------
To do now
----------
Print values of
A) uninitialized
B) fully initialized
C) partially initlaized
D) selective initialisation

array and structure

With different scopes (local, global, file static, function static)
--------------------------------------------------------------------

int x;
int a[3];
double d1[4];
-------------------
struct A y;
union B z;
int a[3];
int b[3]={10,20,30};
int c[3]={10};
-----------------
int d[3];
d[0] d[1] d[2]
d[0]=40;
d[0] d[1] d[2]
-----------------
struct A 
{
	int i;
	float f;
};

struct A m;
m.i => ?
m.f => ?

struct A n={11, 22.33};

struct A o={44};

struct A p={.f=55.66};

int a[3];
a[1]=55;90s

int a[3]={[1]=55};
-----------------------------------------------

float f1[7];
char b[3][4];
double d[5][6][7];

struct A y[2];
int x;

int* j;
int *j;
int * j;
-----------------------------------------------

-----------------------------------------------
int x;
int *p;
int* p
int * p;
-----------------------------------------------
int a;
int *p;

a=45;

p=&a;

*p => ?

*p=>45

*p=34;

*p=> 34;

 
a=>?
--------------------
Type of var1 xyz
Type of &var1 ..... *
Type of &var1 xyz *
--------------------

Type of a => int
Type of &a =>  int   *

-----------------------------------------------
type of a   => int
type of p   => int *
type of *p  => int
type of &a  =>  int *
type of **p => NP
type of &p  =>  int **
type of &&a  => int **
-----------------------------------------------
struct A *p;

p=1000
p+1=> 1000 + sizeof(struct A)

int *p;
p=1000
p+1 = 1000 + sizeof(int) => 1000+4 => 1004

char *p;
p=1000
p+1 = 1000 + sizeof(char) => 1000+1 => 1001

char **p;
p=1000
p+1 = 1000 + sizeof(char *) => 1000+size of pointer => 1000+4 => 1004
(32 bit)
64 bit => 1008
-----------------------

C++
---
----------------------------------------------------------------------------
To do now
----------------
Create a folder C++_Training
Goto that folder
Create a file hello.c in that folder
#include <stdio.h>
int main()
{
	printf("Hello World\n");

	return 0;
}
$gcc hello.c
$ls
$./a.out
$cp hello.c hello.cpp
$g++ hello.cpp
$ls -lrt
$./a.out
--------------------------------------------------

mymalloc.c

#include <stdio.h>
int main()
{
	int *p;
	p=malloc(12);
	return 0;
}
$gcc mymalloc.c
$cp mymalloc.c mymalloc.cpp
$g++ mymalloc.cpp

$man malloc

1. #include <stdlib.h>
2. p=(int *)malloc(12);

myenum.c
-----------------
enum Vehicle {economic, sports, luxury} ;
enum Vehicle myCar;

myCar=0;

---------------------------------------------------
void fn1(int a=10, int b=20)
{
	print a, b
}

int main()
{
	fn1(30,40);
	fn1(70);
	fn1(   90);
	//fn1(, 90)
	fn1();

	return 0;
}

------------------------------------------------
------------------------------------------------
void fn1(int a=10, int b)
{
	print a, b
}
int main()
{
	//fn1(30,40);

	return 0;
}

------------------------
a b c

a,b,c
a,b,c=
a,b=,c=
a=,b=,c=
--------------------------

-------------------------
Day 2
-------
Recap of day 1
Questions
For day 2

-------------------------

int a[3]={10,20,30};

extra feature of array
-----------------------
type wise => name of the array is nothing but pointer to first of element of the array
value wise => name of the array contains address of first element of the array

type of a => int  *
value of a => 1000

a+0 => 1000
a+1 => 1004
a+2 => 1008

*(a+0) => 10
*(a+1) => 20

a[2] <=> *(a+2)

a[n] <=> *(a+n)

type of &a => int (*)[3]
value of &a => 1000

a+1  => 1004
&a+1 => 1012

-----------------------
int b[3][4];

two d array is array of 1d arrays

type of b  => int (*)[4]
type of &b => int (*)[3][4]
type of *b => int *
type of **b => int
type of ***b => NP
type &&b => int (**)[3][4]

*(*(b+1)+2) <=> b[1][2]

b[i][j]  <=>    *(*(b+i)+j)

b=>1000                  => pointer to 1st 1d array
&b=>1000		 => pointer to whole 2d array
*b=>1000		 => pointer to 1st ele of 1st 1d array
**b=> value/content	 => value of 1st ele of 1st 1d array
--------------------------------------------

char *a[6];		//a is an array
int (*b)[7];		//b is a pointer 
int *c(int *);		//c is a function
int (*d)(int *);	//d is a pointer to a function
-------------------------------------------------------

Extra feature of function
------------------------
name of the function is pointer to the function => typewise
name of the function holds add of the function => contentwise 

---------------------------
"xyz"
string => collection/array of const chars

Extra feature of string
-----------------------
string as a whole is also name of the array
--------------------------

const int *p1;			//p1=P/NP?  *p1=P/NP?
int const *p2;			//p2=N/NP?  *p2=N/NP?
int *const p3;			//p3=P/NP?  *p3=P/NP?
const int *const p4;		//p4=P/NP?  *p4=P/NP?
-------------------------

---------------------------
void fn2(int a, int b=30)
{
        print a, b
}
int main()
{
        fn2(60,70);
	fn2(90);
	fn2();

        return 0;b
}

--------------------------------------------
Function overloading
--------------------------------------------
1.
int myadd(int, int);
double myadd(double, double);

2.
int myadd(int, int);
int myadd(int, int, int);

-------------------------------------------
int myadd(int, int);
double myadd(int, int);
-------------------------------------------

--------------------------------
int myadd(int a, int b=30);
int myadd(int a, int b);

myadd(10,20);
myadd(40);
--------------------------------

References
----------------
int i=10;
int &j=i;

//&j=...
//x=&y

print i, j
print &i, &j

i=30;
print i, j

j=40;
print i, j

--------------------------
To do now
---------
in bash
g++ sample.cpp
size a.out
--------------
#include <stdio.h>

int a=10;
int *b=&a;

int main()
{
	return 0;
}

   text    data     bss     dec     hex filename
   1442     560       8    2010     7da a.out
---------------------------
#include <stdio.h>

int a=10;
int &b=a;

int main()
{
	return 0;
}

   text    data     bss     dec     hex filename
   1442     556       4    2002     7d2 a.out

------------------------------------------------
To do now (do hands on on below)
--------------------------------------------------------------------------
1. Default arguments
2. Function overloading a) arguments type varying
                        b) number of arguments varying
3. References a) take an int i, let j be reference
                 print the values, addresses, change value via both
              b) write swap function
                       (i) pass values
                       (ii) pass addresses and take them in pointers
                       (iii) pass values and take them in references
----------------------------------------------
void swap(int a, int b);    //swap(i, j);
void swap(int *a, int *b);  //swap(&i, &j);
void swap(int &a, int &b);  //swap(i, j);
----------------------------------------------

Home assignment
-------------------------------
1. default values should be given during definition or declaration
    or both?
2. draw stack frame when we pass addresses to swap function
------------------------------------------------------------------------------------------------
Indentation example
-------------------
void fn1(void)
{
	declarations

	code body

	return statement
}
void fn2(void)
{
	if (expr1)
	{
		if (expr2)
		{
	
		}
	}
	else
	{

	}
}

------------------------------------------------------------------------------------------------
C++ => C + strict type checking + default arguments + function overloading + references
                                     +
                                Object orientation
------------------------------------------------------------------------------------------------

char *a[4];

name of the array is nothing but pointer to the first element

type of a =>    ...... *
		char * *

	 char *  char *  char *  char *
	---------------------------------
	|	|	|	|	|
	---------------------------------
    a    1000	  1004	  1008	  1012

Assuming 32 bit arch

*(a[1])

type of &a => char *   (*)[4]
type of &&a => char *  (**)[4]

--------------------------------

int arr1[3]={10,20,30};
int (*p)[3];
p=&arr1;

*p[0]
  
*p[1]    =>  *(*(p+1))

(*p)[1]  
p[0][1]
*((*p)+1)
*(p[0]+1)

---------------------------------------------------------------------
type of "hello" ?

const char *

type of &"hello" ?

const char (*)[6]
---------------------------------------------------------------------

-------------------------------
class A
{
	int i;
	void fn1(void)
	{

	}
};
A m;
access=>  m.i    m.fn1()

----------------------------------------------------------
To do now => Create a class having 6 elements (3 data members 
and 3 member functions given access specification as private, protected and public) and access the elements

class A
{
private:
        int i;
protected:
	int j;
public:
	int k;
private:
        void fn1(void)
        {
        }
protected:
        void fn2(void)
        {
        }
public:
        void fn3(void)
        {
        }
};
A m;
//A m={.k=30};
m.fn3
m.fn2
m.fn1
m.k
m.j
m.i
//m.k=10;

Home assignment
-------------------------------
1. Check the default access specification
2. Repeat the above with struct
3. Check the default access specification in struct
----------------------------------------------------------------------------------------------------

A typical CPP program
-----------------------------------
#include <iostream>

using namespace std;

int main()
{
	cout << "Hi" << endl;
	//cout << "Hi" << "\n";
	//use cin as well

	return 0;
}

--------------------------------------------------------------------
We can comment out using namespace std;
In that case we need to do std::cout
--------------------------------------------------------------------

Home assignment
-------------------------------
Look into iostream file, look into extern of cout in std namespace
-------------------------------

header files
/usr/include
            /stdio.h
            /c++/<g++Version>
		             /iostream
ls => list out all files
cat => diaply contents of a file
cmd --version => version of cmd
-------------------------------------

To do now
---------
Create a name spacespace and work with it

namespace A
{
	class C
	{
		public:
			int i;
	};
}

Two ways
1. using namespace A;
    C x;
    print x.i
2. A::C x;
    print x.i

Assignments
------------
Look into iostream file, see whether namespace 
std is created?
Inside that check for externs of cout and cin
------------------------
void swap (int a, int b)
{
	int temp;

	temp=a;
	a=b;
	b=temp;

	print them;
}

int main()
{
	int i;
	int j;

	i=10;
	j=20;
	print them;
	swap(i, j);
	print them;

	return 0;
}
--------------------------------
void swap (int *a, int *b)
{
        int temp;

        temp=*a;
        *a=*b;
        *b=temp;

        print them;
}

int main()
{
        int i;
        int j;

        i=10;
        j=20;
        print them;
        swap(&i, &j);
        print them;

        return 0;
}
-----------------------
void swap (int &a, int &b)
{
        int temp;

        temp=a;
        a=b;
        b=temp;

        print them;
}

int main()
{
        int i;
        int j;

        i=10;
        j=20;
        print them;
        swap(i, j);
        print them;

        return 0;
}
----------

-----------------------------------------------------------------------------------------------------
If we need to initialize the data member what we need to do?
-----------------------------------------------------------------------------------------------------
class A
{
public:
	int i;
	A()
	{
		i=10;
	}
	void fn1(void)
	{

	}
};
A m;
print m.i

--------------------------------------------
class A
{
public:
	int i;
	A(int j)
	{
		i=j;
	}
	void fn1(void)
	{
		print i;
	}
};
A m(25); 
A n(45);
print m.i   n.i
m.fn1();
n.fn1();
----------------------------------

--------------------------------------------
class A
{
public:
        int i;
        A(int j=70)
        {
                i=j;
        }
        void fn1(void)
        {

        }
};
A m(25); A n;
print m.i   n.i
----------------------------------

After testing above code, write two different constructors
one taking no argument, one more taking one argument and test the same
---------------------------------

class A
{
public:
	int i;
	A(int i)
	{
		i=i;
	}
	void fn1(void)
	{

	}
};

A m(25); A n(45);

print m.i, n.i

print m.i   n.i

int *b[3];
int (*c)[4];
int *m(int *);
int  (*n)(int *);
----------------------------

-----------
*  .
*  []
*  ()
-----------

-----------------------------
class A
{
public:
        int i;
        A(int i)
        {
		//i=i;		  //p/np?
		//this.i=i;        //p/np?
                //*this.i=i;      //p/np?
		//(*this).i=i;    //p/np?
		this->i=i;
        }
        void fn1(void)
        {
		print i
        }
};
A m(25); A n(45);
print m.i   n.i
m.fn1();
n.fn1();

---------------------------
class A
{
public:
	A()
	{ cout
	}
	void fn(void)
	{cout
	}
	~A()
	{ cout
	}
};
A obj1;
void fn1(void)
{
	A obj2;
}
void fn2(void)
{
	A obj3;
}
int main()
{
	fn1();
	fn2();
	//obj1.fn();
	return 0;
}
-----------------------------------------

Initializer list
----------------
class A
{
public:
        int i;
        A(int j):i(j) 
	{  
		
	}
        void fn1(void)
        {

        }
};
A m(25); A n(45);

-----------------------------------
class A
{
public:
	int i;
	A(int i): i(i) {  }
	void fn1(void)
	{

	}
};
A m(25); A n(45);
----------------
------------------------------------
class A
{
	int i;
public:
	A(int i=57): i(i) {  }
	void fn1(void)
	{

	}
};
A m(25); A n;
---------------------------------------------------
class A
{
public:
	int i;
	A(int i)
	{
		i=i;
	}
	void fn1(void)
	{
		
	}
};

A m(25); A n(45);
print m.i   n.i
--------------------------------------------------
Solutions
* different name
* this pointer
* initializer list
--------------

----------------------------------------------------------------------------------------
class A
{
public:
	int i;
};
A m;
A n;
//print addresses of m.i and n.i
-------------------------------------------------------------------------------------
-----------------------
C
---
static int x;		//file static variable
void fn1(void)
{
	static int y;	//function static variable
}
//Function can also be static
static void fn2(void)
{

}
------------------------

-------------
Static members
--------------
class A
{
public:
	static int i;
};

//int A::i;
int A::i=25;

//extern int A::i;  //in header file

print A::i

A m;
A n;

print m.i, n.i, A::i
change using m.i / n.i / A::i
print m.i, n.i, A::i
print &m.i, &n.i

--------------------
Day 3
-------
Recap of day 2
Questions
For day 3

-------------------------------------------------------------------------------------
Static member functions also
---------------------------------------------
class A
{
public: 
        static int i;
	int j;
	static void print_i(void)
	{
		cout << i << endl;	//P/NP?
		//cout << j << endl; 	//P/NP?
	}
};

int A::i=25;

int main()
{
	A::print_i();
	
	return 0;
}

-------------------------------------------------------------------------
If i is data member, if we do A m; A n;
How many i's will be there? Is there any link bet them?
-------------------------------------------------------------------------

--------------------------------------------------------------------------
Where all we use ::

* namespace
* accessing static data members, static member functions
* to access global variable/object within a function
	let us say we have a global variable by name var1
	let us say we have a local variable also by name var1
	inside that function
		  var1 => local
		::var1 => global
* When we define member functions coutside the class
returnType Classname::memberFunctionName(arguments)
{

}
--------------------
class A
{
	void fn1(void)
	{

	}
};
One more way:

class A
{
	void fn1(void);
};

//void fn1(void) //fn1 is not a function, but a member function
void A::fn1(void)
{

}
----------------
put class in myclass1.chh

put member functions defintions in myclass1.cpp

objects you will create in main.cpp
----------------

To do now
----------
* Work with static data members (done already)
* Work with static member functions
* Write member function definition outside the class and check

--------------------------------------------------------------------------

--------------------------------------------------------------------------
default constructor
	* the one which takes no arg
	* either written by the programmer of generated by the compiler
	* compiler generates default constructor, only if programmer has not
	  written any constructor
--------------------------------------------------------------------------
class A
{
	A() { }
};
A m;
--------------
class A
{

};
A m;
--------------
class A
{
	A(int i) { }
};
A n(10);
A m;
---------------
class A
{
	A() { }
	A(int i) { }
};
A n(10);
A m;
----------------

Pointer as data member
----------------------
--------------------------------------------------
class A
{
	int *p;
public:
	A() {p=malloc(4);}
	void fill(void) {*p=97;}
	void show(void) {cout << p << "\t" << *p << endl;}
	~A() {free(p);}
};
int main()
{
	A m; m.fill(); m.show(); return 0;
}
//instead of malloc(4), use new int[1]
//instead of free(p), use delete p
-------------------------------------------------------------------------------------

To do now
-----------
add A n(m) after A m;
compile, execute, observe
-------------------------------------------------
A n(m); //A n; n=m;


valgrind ./a.out
-------------------

To do now
----------
* Work with initilizer list (done already)
* pointer as data member
* usage of new, delete

Update the above code with 
A m;
A n(m);   //A n; n=m;

-------------------------------------------

A obj1;
A &refObj1=obj1;

---------------------------------------------------------------------------
Inheritance
-----------
		Automobiles
		-----------------

two wheelers		Four wheelers

motor cycle             car

----------------------------------------------------------------------------------

         Access
         Modifier
class B: public A
{


}
--------------------------------------------------

B y;

How are the elements inherited?
--------------------------------------------------
			              Access Specifier
			              --------------------------
		                public               protected           private	
Access Modifier
-----------------------
public		                public               protected            NA
protected                       protected            protected            NA
private                         private              private              NA
---------------------------------------------------------------------------------------------------------------------------------------------
class A
{
	private:
		int i;
	protected:
		int j;
	public:
		int k;

};

class B:protected A
{
	int p;
	//is k accessible here?
	void xyz(void)
	{
		//cout << i << endl;
		cout << j << endl;
		cout << k << endl;
	}
};

A m;
can I do m.k?
m.k=100;

B n;
can I do n.k?
n.k => will it be 100?
--------------------------------------------------------------
To do now
----------

Create class A having 3 data members and 3 member functions each given access
specifiers public, protected and private respectively.

Create class B which inherits from A. Inherit with access modifier public.
Let it additionally have 3 data members and 3 member functions 
each given access specifiers public, protected and private respectively.

Create object of class B. Access all 12 elements.
-----------------------------------------------------------------------------------------------------------------------------------------------

class A
{
private:	int i1;
protected:	int j1;
public:	int k1;
private:	fn1() {i1 } 
protected:	fn2() { j1  fn1()}
public:	fn3() { k1  fn2()}
};
class B:public A
{
private:	int i2;
protected:	int j2;
public:	int k2;
private:	fn4(
) {} 
protected:	fn5() {}
public:	fn6() {}
};

To do now
----------
* test above code (done)
* print j1 and k1 in fn6, call fn6 through object of class B
* print j1 and k1 through object of class B
* reapeat the above with
	* access modifier as protected
	* access modifier as private

int main()
{
	B y;
/*
	A x;
	x.i1    	x.j1    	x.k1
	x.fn1()	x.fn2()	x.fn3()
*/
}
-----------------------------
Continuation of C++
	Inheritance continuation
	Overriding
	Operator overloading
-----------------------------

To do now
----------
* Upgrade yesterday's code adding constructor and destructor
  both in class A and class B with couts such as I am constructor of A ....
------------------------------
A(int i): i(i) { }

B(int i, int j): A(i), j(j) { }

To do now
----------
* upgrade the code 
	* upgrade the constructors
		* upgrade class A constructor (3 args)
			* use initializer list
		* upgrade class B constructor(6 args)
			* use initializer list
				* to initialize base class data members use 
				  A(.....)
---------------------------------------------------
C(int i, int j, int k): B(i, j), k(k) { }
------------------
A m(10)
m.i
-------------------
B n(30, 40)
n.i  n.j
m.i
-----------------------

Repeat above one with access modifier protected
------------------------------------------------------------------------------------------------------
Repeat above one with access modifier private
------------------------------------------------------------------------------------------------------
Repeat above one without giving any access modifier (default)
------------------------------------------------------------------------------------------------------
Repeat above one with constructors and destructors
------------------------------------------------------------------------------------------------------
Repeat above one with constructors and destructors parameterizing
------------------------------------------------------------------------------------------------------
Repeat above one with constructors and destructors with initializer list
------------------------------------------------------------------------------------------------------
In the derived class, how do we initialize base class data members?

class A
{
	public:
		int e; int f; int g;
	A(int i, int j, int k):e(i), f(j), g(k) { }
	/*A(int i, int j, int k):
	{
		i=i;
		j=j;
		k=k;
	}*/
};

class B: public A
{
	public:
		int x; int y; int z;
	B(int i, int j, int k, int l, int m, int n):A(i,j,k), x(l), y(m), z(n) { }
};

B x1(10,20,30,40,50,60);
//A y1(70,80,90);
//A y1(10,20,30);

----------------------
To do now
----------
* create B m(10,20,30,40,50,60); 
* access the elements  //to do later
* write destructors both in A and B
* write couts in constrctors and destructors
* observe the output

-------------------------
To do now
---------
* Create class A with 6 elements. Create class B with 6 more elements.
  Inherit B from A. Create object of B. Try accessing all 12 elements.
* Write constructor in A. Write constructor in B.
* Work with above using access modifier as public

To do later
------------
* Work with above using access modifier as protected and private

Types of inheritance
--------------------------------
Single
Multi-level
Multiple
Hierarchical
Dimond (hybrid)

Single
-----------
     A
     ^
     |
     B

Note: Arrow should point towards base class
-------------------------------------------------------------------------------------------------------------------------------------------------
To do now
------------
Verify all the types of inheritance
	* multilevel (A, B , C)
	* multilple
		* create class A, having 3 data memebers, 3 member functions
		* create class B, having 3 data memebers, 3 member functions
		* create class C from class A and class B
			* class C let it have additional 3 more data memembers
			  and 3 more member functions
		* write constructors and destructors
			//class C:public A, B
			class C:public A, public B
		* Hierarchical
		* Hybrid / diamond
-------------------------------------------
To do now
----------
Observe the problem in diamond (hybrid) inheritance

--------------------------------------------------------------------------------------------------------
class A
{
	public:
		int i;
};

class B: public A 
{

};

class C: public A
{

};

class D: public B, public C
{

};

int main()
{
	D obj1;
	cout << obj1.i <<endl;    //error, ambiguity

	return 0;
}



Two solutions
---------------------
1. Two copies
	cout << obj1.B::i <<endl;   
	cout << obj1.C::i <<endl;  
2. One copy
Inherit virtually
class B: virtual public A
class C: virtual public A
        cout << obj1.i << endl;
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
	cout << &obj1.B::i <<endl;   
	cout << &obj1.C::i <<endl;   
---------------------------------------------------------------------------------------------------------

D(int i, int j, int k, int l): B(i, j), C(i, k), l(l) { }

D(int i, int j, int k, int l, int m): B(i, j), C(k, l), m(m) { }

D(int i, int j, int k, int l, int m): A(i), B(i,j), C(k, l), m(m) { }
--------------------------------------------------------------------------------------------------------

1. macro
#define myadd(a, b) a+b
#define myadd(a, b) (a)+(b)
#define myadd(a, b) ((a)+(b))

2. function
int myadd(int a, int b)
{
        return (a+b);
}

3. inline function
inline int myadd(int a, int b)
{
        return (a+b);
}

-------------------------
Inline
-------------------------
#include <stdio.h>

inline int myadd(int a, int b)
{
	return (a+b);
}

int main()
{
	int c;

	c=myadd(10, 20);

	return 0;
}
-----------------------------

class A
{
public:
	int i;
	void fn1(void)
	{
		cout ....
	}
};

----------------------------
class A
{
public:
	int i;
	void fn1(void);
};

void A::fn1(void)
{

}
//need to use inline keyword
-----------------------------

To do now
--------------------
-------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
To do now
---------

Create a class A having a member function fn1 printing "I am in fn1 of A"
Create a class B inheriting from A
In class B also create a member function fn1 printing "I am in fn1 of B"
Create a class C inheriting from B
In class C also create a member function fn1 printing "I am in fn1 of C"
-------------------------------------------------------
Create object of A and access fn1
Create object of B and access fn1
Create object of C and access fn1
-------------------------------------------------------
A obj1;
B obj2;
C obj3;

obj1.fn1();
obj2.fn1();
obj3.fn1();

--------------------------------------------------------------------
Create pointer to A
Assign the address of object of class A
Access fn1 through pointer
Assign the address of object of class B
Acess fn1 through pointer
Assign the address of object of class C
Acess fn1 through pointer
---------------------------------------------------------
A *ptr;
ptr=&obj1;
ptr->fn1();
ptr=&obj2;
ptr->fn1();
ptr=&obj3;
ptr->fn1();

----------------------------
What is the solution?
Make the base class member function fn1 as virtual function 
(put keyword virtual before the return type)

class A
{
	public:
		virtual void fn1(void)
		//void fn1(void)
		{
			count << "In fn1 of A" << endl;
		}
};

//overriding

//Use virtual keyword for fn1 of A alone and observe
//Use virtual keyword for fn1 of A, B and C and observe
//Use virtual keyword for fn1 of B alone and observe
//Use virtual keyword for fn1 of C alone and observe

When we use virtual keyword, compiler will create
a table called as Virtual Table (VTable) with addresses
to resolve the symbols
---------------------------------------------------------------------------------------------
size a.out without and with virtual
----------------------------------------------
class A
{
	public:
		void fn1(void)
		{

		}
};
-----------------------------------------------------
class A
{
	public:
		virtual void fn1(void)
		{

		}
};
--------------------------------------------------------------

class A
{
	public:
		virtual void fn1(void)=0;
};

------------------------------------------------------------------
Non virutual function
Virtual function
Pure virtual function
------------------------------------------------------------------

To do now
-------------------
Create a class with a pure virtual function
           virtual void fn1(void)=0;
Create an object from that => should not work
Create a pointer to that class => should work

Add couple of more methods, a virtual and a non virtual
And repeat the above

Create derived classes
Access the member functions using objects
Access the member functions using pointer (base class pointer)
-----------------------------------------------------------------------------------------------------------------------------------

* can we create object from the class which is inherited from abstract class
	* yes, only if we define (implement that function) in derived class
	* else, no....as derived class also is abstract

------------------------------------------------

//execise 
//create a data structure
//two ways of implemntation
//a) array (static allocation) implementation
//b) linked (dynamic allocation) implementation

//app: create a stack / queue / list and work with it 
-------------------------------------------------------------
//main.cpp    //otherwise main.C
//one.cpp  one.chh
//two.cpp  two.chh
...
//include one.chh in one.cpp .......
------------------------------------------------------------
g++ main.cpp one.cpp two.cpp
./a.out
--------------------
--------------------------------------------------------------

---------------------
Day 4
-------
Recap of day 3
Questions
For day 4

Update data structure exercise with menu
1. insert
2. delete
3. display
4. exit

program should be terminated only when tester enters 4

----------------------
*.
*[]
*()
----------------------

----------------------------
C++ continuation
	Operator overloading, Friend, file handling, exceptions, Copy
	constructor, templates, STL
-----------------------------
-------------------------- 
---------------------------------------------------------------------------------------------------------------------------------------------
class A
{
	public:
		int data1;
		int data2;
};

A x;
A y;
A z;

x.data1=10
x.data2=30

y.data1=20
y.data2=40

write a generic function (not a member function) to add these two different objects

z=myAdd(x, y);

print z.data1
print z.data2

A myAdd(A i, A j)
{
	A temp;

	temp.data1=i.data1+j.data1;
	temp.data2=i.data2+j.data2;

	return temp;
}
-------------------------------------------------------------
z=myAdd(x, y);   

----------------------------------------------------------------
z=x+y;
----------------------------------------------------------------
A operator+(A m)
{
	A temp;
	
	temp.data1=data1+m.data1; //temp.data1=this->data1+m.data1;
        temp.data2=data2+m.data2;

	return temp;
}

//instead of x+y, make it work for x+2
//Instead of z=x+y, try z=x+2 and observe
#If error, make it working
//If you need to write the definition outside, in that case put the declaration inside the class
A operator+(A);        //<=declaration  or A operator+(A)
A A::operator+(A m)    //<=definition
{
....
}
---------------------------------------------------------------------------
To do now
----------
* add two objects of class A type, using global function
* add two objects of class A type, using operator overloading function

To do now
----------
* make it work for x+y also, x+2 also

cout << "hi";

---------------------------------------------------------
To do now (till network issue gets resolved)
---------
do till 12.15

* go through iostream file
	* see whether extern of cout is there
	* see whether cout extern is within std namespace
	* check class from which cout is generated
* complete data structure exercise
-------------------------------------------------------

string => +

--------------

To do now
-----------------
Write operator overloaded functions to make the following work
z=x-y
z=x-2

x++
++x

operator++()
{

}

operator++(int m)
{

}

-------------------------------------------------------------------------------------------------------------------------
In generic if obj1+obj2 has to work, then a memmber function by name operator+
should have been written in the clsss from which we have created obj1
and type of obj2 should have been taken as a parameter to that member function
--------------------------------------------------------------------------------------------------------------------------

cout << "hi" << 10;

--------------------------------------------------------------------------------
A A::operator++()
A A::operator++(A i);
{

	this->i=this->i+1;
	return *this;                         //return this? or *this?
}

----------------------------------------------------------------
int a=5;
int b;

b=++a     //   b=a++
----------------------------
-------------------------------------------------------------------------------------------
Operator Overloading
? Operator overloading is an important concept in C++.
? It is a type of polymorphism in which an operator is overloaded to give user
defined meaning to it.
? Overloaded operator is used to perform operation on user-defined data
type.
? For example '+' operator can be overloaded to perform addition on various
data types, like for Integer, String(concatenation) etc.
-------------------------------------------------------------------------------------------
Almost any operator can be overloaded in C++.
? These below operators can be overloaded.
? new delete
?+-*/%^&|~
? ! = < > += -= *= /= %=
? ^= &= |= << >> >>= <<= == !=
? <= >= && || ++ -- , ->* ->
? () []
----------------------------------------------------------------------------------------------
Exercise expectations.....
Stack_new myStack;
myStack[5]=10
-----------------------------------------------------------------------------------------------
Operator that are not overloaded are follows
? scope operator - ::
? sizeof
? Period - .
? ternary operator - ?:
----------------------------------------------------------------------
-----------------------------------------------------
//Work with complex numbers
-----------------------------------------------------
c3=c1+c2
Operator overloading

cout << "hi";
----------------------------------------------------------
char *p="hello";
char *q="world";

cout << p+q << endl;

--------------------------------

int *q=1008;
int *p=1000;

q-p=> ? 8/ sizeof(int) => 8/4 => 2

-----------------
char *q=1008;
char *p=1000;

q-p=> ? 8/ sizeof(char) => 8/1 => 8

--------------------------------------
cout << (unsigned long int)p+(unsigned long int)q << endl;
--------------------------------------

#include <string>

string str1;
str1="hello";

string str2;
str2="hi";

cout << str1+str2 << endl;

can we do str1+str2?
why should it work?
Are they one and the same?
------------------------------------------------------------
---------------------------------------------------------------------------
----------------------------------------------------------------------------
see whether operator<< in is there is one of the files, 
in line with iostream?

-----------------------------------------------------------------------------------------
Look into string file, see whether there is a class called as string 
and whether class has operator+?
------------------------------------------------------------------------------------------

string str1="hi";

str1*3 to work, to print hihihi

let us say it doesn't work by default
how do you make it work?

inherit

mystring str1
------------------

g++ file1.cpp
readelf -a a.out
objdump -D a.out
-----------------

----------------------------------------------------------------------------------------------------------
int add(int a, int b)
//inline int add(int a, int b)
{
	return (a+b);
}
int main()
{
	int sum, x=30, y=40;
	sum=add(x,y);
	printf("%d\n", sum);
	return 0;
}

----------------------------
*  [ ]
*  .
*  ( )

int *a[3];
int (*a)[3];

------------------------------		
int *(*(*i())[7])(int *)
int *(*(*j)())[7]
struct C* (*(*k[3])[5])(struct A *, struct B *)
char * (*(*(*l)(int *))[10])(char)
------------------------------
void (*(*m)[3]) (void)

------------------------------------------------------------------------------------------------------
Private elements are they not accessable outside?
-------------------------------------------------------------------------------------------

#include <iostream> 
using namespace std; 

class mycl
{
	int a,b;
public:
	friend int add(mycl x); 
	void set_ab(int i, int j); 
};
 
void mycl::set_ab(int i, int j)
{
	a = i, b = j;
}

int add (mycl x)
{
	return x.a + x.b;
}

int main()
{
	mycl cl;
	//cout << cl.a << endl;
	cl.set_ab(4,5);
	cout << add(cl);

	return 0;
}
----------------------------------------------------------------------------------------------

#include <iostream> 
using namespace std;

class mycl:
{
	int a,b;
public:
	friend class myadd;
	void setab(int i, j);
};
void mycl::setab(int i, int j)
{
	a = i; b = j; 
}
class myadd
{
public:
	int add(mycl x)
	{ return x.a + x.b; }
};
int main()
{
	mycl cl; 
	myadd ad;
	cl.setab(4,5);
	cout << ad.add(cl);
	return 0;
}

----------------------------------------------------------------------------------------------------------

How do we allocate an object dynamically?
A *p;
p=new A;
//use the dynamically created object
delete p;
----------------------------------------------------------------------------------

Assignment
-------------------
How do we check that Virtual Table is created when we 
make member function virtual?
-----------------------------------------------------------------------------------
Can we create array of objects and initialize?
----------------------------------------------------------------------------------

//C
//int a[3];
//int a[3]={10,20,30};
//int a[3]={10};
------------------------
#include <stdio.h>

using namespace std;

class A
{
	public:
		int i;
	A(int i):i(i) { }
};

int main()
{
	A obj[2]={A(10)};

	cout << obj[0].i << endl;
	cout << obj[1].i << endl;

	return 0;
}

-------------------------

File handling
Exception handling
Templates
STL

-----------------------------------------------------------------------------------------------------------------------------------
File handling
----------------

-------------------------------------------------------------------------------------------
//how do we write contents into a file?

#include <iostream>
#include <fstream>
using namespace std;
int main () 
{
	ofstream myfile;

	myfile.open ("example.txt");
	myfile << "Writing this to a file.\n";
	myfile.close();

	return 0;
}
-----------------
In bash
g++ sample1.cpp
./a.out
cat example.txt
-----------------

----------------------------------------------------------------
//how do we read contents from a file?

//using class ifstream
-----------------------------------------------------------------
create a file manually for example 
input.txt
-------------
10
-----------------------------------------------------------------

int i; 
ifstream myfile1;    
myfile1.open("input.txt");  
myfile1>>i; 
myfile1.close()
cout << endl << i << endl;
---------------------------------------------------------------
To do later
-----------------
//if we use fstream, then we need to use flag, such as ios::in or ios::out

fstream  file1;
fstream  file2;
fstream  file3;

file1.open("abc.txt", ios::in);                 //r


file2.open("ijk.txt", ios::out);	       //w

file3.open("mno.txt", ios::in | ios::out);	 //r+
//file3.open("mno.txt", ios::in | ios::out | ios::trunc);//w+
....

...
...
file1.close();
file2.close();
file3.close();

Assignment
------------------
Check what is ios::in? What is it's value? In which file it is available?
|||ly for ios::out as well. See other flags well, example, is there anything for appending?
//how do we know what else is there?
//goto ios::in, see others there

//is_open

//seek or seekp method / member function?

//for binary file, read and write?

//home work, work with binary file, write and reabback, few bytes (raw) or few structures
--------------------------------------------------------------------------------------------

What is output of the following code snippet?

float f1=3.0;

float f2=4.5;

cout << f1 << "\n";
cout << f2 << "\n";

Flags
-----------
* certain flags can be used alone
* certain flags will have to used along with some other flags

cout.setf(flags)
cout.unsetf(flags)

ios::hex ..........
--------------------------------------------------------------------------------------------
cout.unsetf(ios::dec | ios::oct | ios::hex);
cout.setf(ios::oct);
//or
cout.setf(ios::oct,     ios::dec | ios::oct | ios::hex);
//or
cout.setf(ios::oct,ios::basefield);
--------------------------------------------------------------------------------------------
int x = 42;
cout.setf(ios::oct,ios::basefield);
cout << x << '\n';
cout.setf(ios::hex,ios::basefield);
cout << x << '\n';
cout.setf(ios::dec,ios::basefield);
cout << x << '\n';
--------------------------------------------------------------------------------------------
showbase
--------------------------------------------------------------------------------------------
showpos
uppercase
--------------------------------------------------------------------------------------------
Formatting of the output
fill and width methods (member functions in cout)
flags adjustfield along with righ, left, internal

int x = 42;
cout.setf(ios::showpos);
cout.fill('*');
cout.setf(ios::right,ios::adjustfield);     //reverse order will it work?
cout.width(6);
cout << x << '\n'; // Outputs ***+42
cout.setf(ios::left,ios::adjustfield);
cout.width(6);
cout << x << '\n'; // Outputs +42***
cout.setf(ios::internal,ios::adjustfield);
cout.width(6);
cout << x << '\n';
// Outputs +***42

-------------------------------------------------------------------------------------------
precision method is also there

float y = 23.1415;
cout.precision(1);
cout << y << '\n'; 
cout.precision(2);
cout << y << '\n'; 
cout.precision(3);
cout << y << '\n'; 
-------------------------------------------------------------------------------------------
Flags
----------
int x = 42;
cout.setf(ios::oct,ios::basefield);
cout << x << '\n';
cout.setf(ios::hex,ios::basefield);
cout << x << '\n';
cout.setf(ios::dec,ios::basefield);
cout << x << '\n';

Manipulators
--------------
#include <iostream.h>
int x = 42;
cout << oct << x << endl; 
cout << hex << x << endl; 
cout << dec << x << endl; 

-------------------------------------------------------------------------------------------
Exercise upgradation (using files)
-----------------------------------------------------
Create two files manually input.txt
Program will read from input.txt and write into output.txt
Execute the code, compare expected_output.txt and observed_output.txt
example of input.txt
1
10
1
20
1
30
3
2
3
2
3
4

----------------------------------------------------------------------
----------------------------------------------------------------------
Exception handling
-----------------------------

Exceptions
------------
Try throw -catch block
? Exceptions provide a way to react to exceptional circumstances (like
runtime errors) in programs by transferring control to special
functions called handlers.
? To catch exceptions, a portion of code is placed under exception
inspection.
? This is done by enclosing that portion of code in a try-block.
? When an exceptional circumstance arises within that block, an
exception is thrown that transfers the control to the exception
handler.
? If no exception is thrown, the code continues normally and all
handlers are ignored.

An exception is thrown by using the throw keyword from inside the try
block.
? Exception handlers are declared with the keyword catch, which must
be placed immediately after the try block:
----------------------------------------------------------------------

Try throw -catch block
----------------------------------------------------------------------
int main() 
{
	class A
	{
	};
	A x;

	try
	{
		try
		//throw x;
		//throw 12.34;		
		//throw y;
		throw 10;
	}
	catch (int e) 
	{
		cout << "An exception occurred. Exception of int" << '\n'; 
	}
	catch (A m) 
	{
		cout << "An exception occurred. Exception of A" << '\n'; 
	}
	return 0;
}
-----------------------------------------------------------------------
try {
        char ch;
        char * ch1;
// code here
        throw 10;
        //throw ch;
        //throw 'a';
        //throw 33.44;
        //throw ch1;
}
catch (int param) { cout << "int exception"; }
catch (char param) { cout << "char exception"; }
catch (...) { cout << "default exception"; }

--------------------------------------------------------------------------------

printf("%d\n", sizeof('a'));

To do now
char *x;
string y;
throw them

//new throws bad_alloc exception

Create two catch blocks one with char * and one more with string, observe the behaviour.
--------------------------------------------------------------------------------

//bad_alloc is an exception
//please try the following
//allocate a huge chunk of space using malloc
//and see whether you will get bad_alloc exception
//allocate a huge chunk of space using new
//and see whether you will get bad_alloc exception

#include <iostream>
using namespace tsd;
int main()
{
        try
        {
                p= new int [1000000];
                //p=malloc(1000000*sizeof(int))
        }
        catch(bad_alloc m)
        {
                cout << "not enough space" << "\n"
                cout << m.what();
        }
}

-----------------------------------------------------------------------------------
there is a base class called exception
probabley bad_alloc would have been derived from it?
-----------------------------------------------------------------------------------
can we create our exception?
-----------------------------------------------------------------------------------
class MyException : public exception
{
        public :
        const char * what()
        {
                return "User created C++ Exception";
        }
};

MyException x;

try
{
        throw x;
}
catch (MyException m)
{
        cout << m.what() << endl;
}

Assignment
* look into file exception

int main()
{
        MyException x();
        try
        {
                throw x;
                //throw MyException();
        }
        catch(MyException e)
        {
                std::cout << "MyException caught";
                std::cout << e.what() << std::endl;
        }
        catch(std::exception& e)
        {
                //Other errors
        }
}
-------------------------------------------------------------------------------------------
Upgrade data structure exercise with execption (going out of boundary)
----------

----------------
Day 5
-------
Recap of day 4
Questions
For day 5

------------------
Crash analysis
	* dmesg
	* objdump

	* dmesg
	* addr2line

Note: addr2line will work, if you compiled your proram with -g option
-----------------
Code is malfunctioning
	* review
	* print messages
	* use a debugger
		* Usage of gdb
-----------------
Usage of Makefile
----------------
Usage of valgrind
---------------------
Write a code with new, without delete
g++ sample.cpp
valgrind ./a.out
Repeat the same adding delete

Copy constructor

Template
STL
STL components
Array Vs Vector
Dynamic array of C Vs Vector

Lambda
Enumerations
Usage of move
Copying in C, C++ 
RTTI

Inline

Virtual destructor

Introduction to design patterns
Desktop C++ Vs Embedded C++
Drawing stack frames
---------------------------------

-------------------------------
class A
{
	int *p;
public:
	A() { p=(int *)malloc(40); /* p=new int[10]; */ }
	void fill(void) { *p=34; }
	void show(void) { cout << p << "\n" << *p << "\n"; }
	~A() { free(p); /* delete p; */ }
};
int main()
{
	A x;  x.fill(); x.show(); A y(x);  //A y; y=x;
	y.show(); 	return 0;
}

//Problem, shallow copy is being done
//solution, do deep copy by writing your own constructor (copy constructor)
---------------------------------------------------------------------------------
A(const A &m)
{
	cout << "In copy constructor" << endl;
	p=(int *)malloc(40);    //this->p=malloc(40);
	*(p)=*(m.p);
}
----------------------------------------------------------------------------------

class A
{
        int *p;
public:
        A() { p=(int *)malloc(40); //p=new int[10]; }
        void fill(void) { *p=34; }
        void show(void) { cout << p << "\n" << *p << "\n"; }
        ~A() { free(p); //delete p; }
};
int main()
{
        A x;  
	x.fill(); 
	x.show(); 
	A y(x);  //A y; y=x;
        y.show();       return 0;
}
----------------------------

class A
{
        int *p;
public:
        A() { p=(int *)malloc(40); //p=new int[10]; }
	//A(A m)
	//A(A &m)
	//A(const A &m)
	A(const A &m)
	{
		//1. create a new space
        	p=(int *)malloc(40);    //this->p=malloc(40);
		//2. copy the values from old space to new space
		*(p)=*(m.p);		
	}
        void fill(void) { *p=34; }
        void show(void) { cout << p << "\n" << *p << "\n"; }
        ~A() { free(p); //delete p; }
};
int main()
{
        A x;  
        x.fill(); 
        x.show(); 
        A y(x);  //A y; y=x;
        y.show();       return 0;
}

/*
A y;
y=x;
*/

--------------------
A()
A(int )
A(int, int )
A(const A &n)
--------------------

A m;
A n(m);
------------
A m;
A n;
n=m;
------------
class A
{

};

int main()
{
	A obj1;

	obj1();  //P/NP?

	return 0;
}

--------------------------

C++ continuation
	Templates and STL, lambda, enumerations, design patterns
Other information

------------------------------------------------------------------------------------------
Introduction to templates

Templates
---------
int maximum(int a, int b, int c)
{
	int max = a;

	if (b > max) max = b;
	if (c > max) max = c;

	return max;
}
-------------------------------------------------------------------------------------------
float maximum(float a, float b, float c)
{
	float max = a;

	if (b > max) max = b;
	if (c > max) max = c;

	return max;
}
------------------------------------------------------------------------------------------
double maximum(double a, double b, double c)
{
	double max = a;

	if (b > max) max = b;
	if (c > max) max = c;

	return max;
}

-------------------------------------------------------------------------------------------
//can we avoid writing mutilple copies of the code?
//The logic is exactly the same, but the data type is different.
//template
//make our code generic with respect to type
//later we can we can work on the specific type
-------------------------------------------------------------------------------------------

To do now
-----------------
* create a template function, which uses single type
  call the function with different type of parameters and check
* create a template function, which use multiple types
  call the function with different type of parameters and check
* create a template class, which uses single type
  create multiple objects with different types and check
* work with available template class stack

template <class T>
T maximum(T a, T b, T c)
{
	T max = a;

	if (b > max) max = b;
	if (c > max) max = c;

	return max;
}

int i1, i2, i3;

int m = maximum(i1, i2, i3);

//will compiler create the code for template?

//expt: square function to work for interger, float, double
--------------------------------------------------------------------------------------------

Multiple Generic Types
template<class T, class U, class V>
void tempfun(T a, U b, V c)
{
	cout<<a<<endl<<b<<endl<<c;
}
int main()
{
	int i=10;
	float j=3.14f;
	char k='a';

	tempfun(i, j, k);

	return 0;
}

------------------------------------------------------------------------------------------
//we could write functions as template functions
//can we create classes as template classes?

#include <iostream>
using namespace std;
template <class T>
class mypair 
{
	T a, b;
public:
	mypair (T first, T second)
	{a=first; b=second;}
	T getmax ();
	//.......
};
template <class T>
T mypair<T>::getmax ()
{
	T retval;
	retval = a>b? a : b;
	return retval;
}
int main () 
{
	mypair <int> myobject (100,75);
	mypair <char> myobject2 ('j','r');
	cout << myobject.getmax();
	cout << myobject2.getmax();
	return 0;
}
----------------------------------------------------------------------------------------------
* Exercise upgradation
update your data structure exercise to work with
* operator overloading  [ ]
* file handling: input.txt, expected_ouput.txt
                 program let it read from input.txt and 
                 write the output.txt
* exception handling for more than let us say 
  10 elements
* the code needs to work for stack / list of integers also, 
   stack / list of float also
----------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------
//standard templates are made available in a library 
//called STL (standard template library)
#include <iostream>
#include <stack>
using namespace std;
int main ()
{ 
	stack<int> mystack;

	for (int i=0; i<5; ++i)
		mystack.push(i);

	cout << "Popping out elements...";

	while (!mystack.empty())
	{
		cout << " " << mystack.top();
		mystack.pop();
	}
	cout << endl;

	return 0;
}

----------------------------------------------------------------------------------------------

Assignment
---------------------
* how do we know other functions (member functions supported in stack)
* goto the file stack and look into them

* work with queue
-----------------------------------------------------------------------------------------------
/usr/include/stdio.h
/usr/include/c++/<g++ version>/iostream
			      /stack
			      /queue
STL
---
* algorithms
	* non modifying sequence operations => find_if, count
	* modifying sequence operations => remove
	* sorting
	* binary search
	* heap
	* min, max
* containers
	* sequence containers
		* arrays
		* vector
		* dequeue
		* forward_list
		* list
	* associative containers
		* set
		* map
		* multiset
		* multimap
	* unordered associative containers
		* unordered_set
		* unordered_map
		* unordered_multiset
		* unordered_multimap
	* container adapters
		* stack
		* queue
		* priority_queue
* iterators
	* input
	* output
	* forward
	* bidirectional
	* random access

----------------
cppreference.com
----------------

Lambda
Enumerations
Design patterns
Other information

Lambda
-------
* to create ananymous function objects (functors)
* don't need to overload () operator

auto x = []() {
	//body
}

[] => lambda introducer....start of lambda
() => parameter list...similar to () operator of a function
auto => to automatically deduce the return type


x();
-----------
auto add = [] (int a, int b) {
  // always returns an 'int'
  return a + b;
};
-----------

-------------------
auto operation = []  (int a, int b,  string op) -> double {
  if (op == "sum") {
    // returns integer value
    return a + b;
  } 
  else {
    // returns double value
    return (a + b) / 2.0;
  }
};
------------------

capture clause
-----------------
int num_main = 100;

// get access to num_main from the enclosing function
auto my_lambda = [num_main] () {
  cout << num_main;
};
------------------
int num_main = 100;

// access the address of num_main variable
auto my_lambda = [&num_main] () {
  num_main = 900;
};
-----------------

stateless lambda
----------------

auto mylambda1 = [](){
  int i = 0;
  cout << i++;
}

use this multiple times, check the output
-----------------

stateful lambda
---------------

auto mylambda2 = [i = 0]() mutable { cout << ++i << ' '; };

use this multiple times, check the output
-----------------

Enumerations
-------------
enum vehicle {economic, sports, luxury};

enum vehicle myCar;
enum vehicle myJeep;

myCar=economic;
myJeep=sports;

Enums as flags
---------------
Give values 1, 2, 4, 8 ....
So that, bit wise operations can be performed

Scoped enumerations
--------------------
Enum classes are called as scoped enumerations

// Declaration
enum class EnumName{ Value1, Value2, ... ValueN};

// Initialisation
EnumName ObjectName = EnumName::Value;

Advantage=> strongly typed (example comparison not allowed)
	    , strongly scoped (can not access directly)
----------------------

Will this work?
    enum class Color { Red,
                       Green,
                       Blue };
    enum class Color2 { Red,
                        Black,
                        White };
-----------------------
Will this work?
    enum Color { Red,
                       Green,
                       Blue };
    enum Color2 { Red,
                        Black,
                        White };

----------------------
unscoped enum
scoped enum
----------------------

Design patterns
---------------
Design patterns are programming language independent strategies for solving a common problem. That means a design pattern represents an idea, not a particular implementation. By using design patterns, you can make your code more flexible, reusable, and maintainable.

* Creational
	* Singleton
* Structural
	* Adapter
* Behavioral
	* Observer

Singleton
---------
Intent:
Singleton is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance

Problem:
The Singleton pattern solves two problems at the same time, violating the Single Responsibility Principle:

1. Ensure that a class has just a single instance. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resourcefor example, a database or a file.

Heres how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, youll get the one you already created.

Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.

2. Provide a global access point to that instance. Remember those global variables that you (all right, me) used to store some essential objects? While theyre very handy, theyre also very unsafe since any code can potentially overwrite the contents of those variables and crash the app.

Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.

Theres another side to this problem: you dont want the code that solves problem #1 to be scattered all over your program. Its much better to have it within one class, especially if the rest of your code already depends on it.
Nowadays, the Singleton pattern has become so popular that people may call something a singleton even if it solves just one of the listed problems.

Solution:
All implementations of the Singleton have these two steps in common:

Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.
Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.
If your code has access to the Singleton class, then its able to call the Singletons static method. So whenever that method is called, the same object is always returned.


Adapter
-------
Intent:
Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate

Problem:
Imagine that youre creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user.

At some point, you decide to improve the app by integrating a smart 3rd-party analytics library. But theres a catch: the analytics library only works with data in JSON format.

You could change the library to work with XML. However, this might break some existing code that relies on the library. And worse, you might not have access to the librarys source code in the first place, making this approach impossible.

Solution:
You can create an adapter. This is a special object that converts the interface of one object so that another object can understand it.

An adapter wraps one of the objects to hide the complexity of conversion happening behind the scenes. The wrapped object isnt even aware of the adapter. For example, you can wrap an object that operates in meters and kilometers with an adapter that converts all of the data to imperial units such as feet and miles.

Adapters can not only convert data into various formats but can also help objects with different interfaces collaborate. Heres how it works:

The adapter gets an interface, compatible with one of the existing objects.
Using this interface, the existing object can safely call the adapters methods.
Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.
Sometimes its even possible to create a two-way adapter that can convert the calls in both directions.


Observer
--------
Intent:
Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object theyre observing.

Problem:
Imagine that you have two types of objects: a Customer and a Store. The customer is very interested in a particular brand of product (say, its a new model of the iPhone) which should become available in the store very soon.

The customer could visit the store every day and check product availability. But while the product is still en route, most of these trips would be pointless.

Solution:
The Observer pattern suggests that you add a subscription mechanism to the publisher class so individual objects can subscribe to or unsubscribe from a stream of events coming from that publisher. Fear not! Everything isnt as complicated as it sounds. In reality, this mechanism consists of 1) an array field for storing a list of references to subscriber objects and 2) several public methods which allow adding subscribers to and removing them from that list.


Other information
-------------------

class A
{
public:
	int i;
	//A() {}
	A(int i):i(i){}
};

A x[3]={A(10)};

x[0].i => ?
x[1].i => ?
x[2].i => ?
-------------
int m[3]={25};

* Virtual destructor
Base *b = new Derived();
// use b
delete b; // problem
----------------------------------------------------
Embedded Vs Desktop
-------------------
exceptions
rtti
--------------------
g++ -fno-exceptions  sample.cpp
g++ -fno-rtti  sample.cpp
( )
<  > => dynamic casting
RTTI => run time type information
     => typeid

-----------------------------------------------------
Abstraction: abstract class, pure virual, templates
Encapsulation: class
Data hiding: access specifiers, access modifiers
Polymorphism: default args, fn overloading, fn overriding, oper overloading
Inheritance: class, class.....

----------------------------------------------------

--------------------------------------------------------------------------------------------
Vinod Kulkarni
+919945732510
vinodkallagi@gmail.com
Also on LinkedIn
---------------------------------------------------------------------------------------------
